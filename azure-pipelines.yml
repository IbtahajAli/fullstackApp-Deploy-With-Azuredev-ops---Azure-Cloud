trigger:
- main

pool:
  name: local-pool

variables:
  # --- TERRAFORM VARS ---
  tfVersion: '1.9.0'
  workingDir: '$(System.DefaultWorkingDirectory)/terraform'
  bkResourceGroup: 'rg-terraform-backend'
  bkStorageAccount: 'tfstatedevopsapp123'
  bkContainer: 'tfstate'
  bkLocation: 'eastus'
  
  # --- CONNECTIONS ---
  acrLoginServer: 'devopsacr123.azurecr.io' 
  acrServiceConnection: 'acr-connection'    
  aksServiceConnection: 'aks-connection'            
  
  # --- IMAGES ---
  backendImageName: 'backend-app'
  frontendImageName: 'frontend-app'
  tag: '$(Build.BuildId)'
  
  # --- APP CONFIG ---
  # Update this to the Real Azure IP after deployment
  backendUrl: 'http://localhost:5000' 

  # --- SECURITY ---
  # Add 'snykToken' to your ADO Library/Variables as a secret!
  # If you don't have one yet, the Snyk task is set to continueOnError: true

stages:
# ----------------------------
# STAGE 1: INFRASTRUCTURE
# ----------------------------
- stage: Terraform
  displayName: "Infrastructure"
  jobs:
  - job: TerraformWorkflow
    displayName: "Terraform Workflow"
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(tfVersion)

    # 1. BOOTSTRAP (Repair Storage & Get Key)
    - task: AzureCLI@2
      displayName: "1. Bootstrap & Setup"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: |
          Write-Host "Checking Infrastructure Backend..."
          $rgExists = az group exists --name $(bkResourceGroup)
          if ($rgExists -eq "false") { az group create --name $(bkResourceGroup) --location $(bkLocation) }

          $accCheck = az storage account check-name --name $(bkStorageAccount) | ConvertFrom-Json
          if ($accCheck.nameAvailable -eq $true) {
             az storage account create --name $(bkStorageAccount) --resource-group $(bkResourceGroup) --location $(bkLocation) --sku Standard_LRS
             Start-Sleep -Seconds 10
          }

          $key = az storage account keys list --resource-group $(bkResourceGroup) --account-name $(bkStorageAccount) --query "[0].value" -o tsv
          $containerExists = az storage container exists --name $(bkContainer) --account-name $(bkStorageAccount) --account-key $key --query "exists" -o tsv
          if ($containerExists -ne "true") { az storage container create --name $(bkContainer) --account-name $(bkStorageAccount) --account-key $key }

          Write-Host "##vso[task.setvariable variable=ARM_ACCESS_KEY;issecret=true]$key"

    # 2. INIT
    - task: AzureCLI@2
      displayName: "2. Terraform Init"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform init -input=false -reconfigure
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

    # 3. PLAN
    - task: AzureCLI@2
      displayName: "3. Terraform Plan"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform plan -out=tfplan -var "sql_password=$env:SQL_PASS"
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)
        SQL_PASS: $(sql_password)

    # 4. APPLY
    - task: AzureCLI@2
      displayName: "4. Terraform Apply"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform apply -auto-approve tfplan
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

# ----------------------------
# STAGE 2: SECURITY (Snyk & Trivy)
# ----------------------------
- stage: Security
  displayName: "Security Scans"
  dependsOn: Terraform
  jobs:
  - job: SnykScan
    displayName: "Snyk (Dependencies)"
    continueOnError: true # Won't stop pipeline on failure
    steps:
    - script: |
        echo "Installing Snyk..."
        npm install -g snyk
        echo "Authenticating..."
        # Requires 'snykToken' variable in Pipeline Library
        snyk auth $(snykToken)
        echo "Scanning Backend..."
        snyk test backend/ --continue-on-failure
      displayName: "Run Snyk Scan"
      condition: ne(variables['snykToken'], '') # Only run if token exists

  - job: TrivyScan
    displayName: "Trivy (Filesystem)"
    continueOnError: true
    steps:
    - script: |
        echo "Running Trivy..."
        # Uses Docker to run Trivy (No install needed)
        docker run --rm -v "$(System.DefaultWorkingDirectory):/app" aquasec/trivy fs /app --exit-code 0
      displayName: "Run Trivy Scan"

# ----------------------------
# STAGE 3: BUILD & PUSH
# ----------------------------
- stage: BuildAndPush
  displayName: "Build Docker Images"
  dependsOn: Security
  condition: succeeded()
  jobs:
  - job: BuildImages
    steps:
    - task: Docker@2
      displayName: "Build Backend"
      inputs:
        command: buildAndPush
        repository: $(backendImageName)
        dockerfile: 'backend/Dockerfile'
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(tag)
          latest

    - task: Docker@2
      displayName: "Build Frontend"
      inputs:
        command: buildAndPush
        repository: $(frontendImageName)
        dockerfile: 'frontend/Dockerfile'
        containerRegistry: $(acrServiceConnection)
        arguments: '--build-arg REACT_APP_API_URL=$(backendUrl)'
        tags: |
          $(tag)
          latest

# ----------------------------
# STAGE 4: DEPLOY (AKS)
# ----------------------------
- stage: Deploy
  displayName: "Deploy to AKS"
  dependsOn: BuildAndPush
  condition: succeeded()
  jobs:
  - deployment: DeployAKS
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureCLI@2
              displayName: "Set K8s Secret & Deploy"
              inputs:
                azureSubscription: 'azure-rm-terraform'
                scriptType: 'ps'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  # --- THE FIX FOR "NO HOST" ERROR ---
                  # Delete old config from previous cluster runs
                  if (Test-Path "$env:USERPROFILE\.kube\config") {
                      Write-Host "Removing stale kubeconfig..."
                      Remove-Item "$env:USERPROFILE\.kube\config" -Force
                  }

                  # Get New Credentials
                  az aks get-credentials --resource-group devops-rg --name devops-aks --overwrite-existing
                  
                  # Create/Update Secret
                  kubectl create secret generic db-secret --from-literal=password=$(sql_password) --dry-run=client -o yaml | kubectl apply -f -

            # Deploy Manifests
            - task: KubernetesManifest@0
              displayName: "Apply Manifests"
              inputs:
                action: 'deploy'
                kubernetesServiceConnection: $(aksServiceConnection)
                namespace: 'default'
                manifests: |
                  $(System.DefaultWorkingDirectory)/manifests/deployment.yml
                  $(System.DefaultWorkingDirectory)/manifests/service.yml
                containers: |
                  $(acrLoginServer)/$(backendImageName):$(tag)
                  $(acrLoginServer)/$(frontendImageName):$(tag)

# # ----------------------------
# # STAGE 5: DESTROY (Manual)
# # ----------------------------
# - stage: DestroyInfra
#   displayName: "Destroy Infrastructure"
#   dependsOn: Deploy
#   condition: eq(variables['Build.Reason'], 'Manual') 
#   jobs:
#   - job: TerraformDestroy
#     displayName: "Terraform Destroy"
#     steps:
#     - task: TerraformInstaller@0
#       inputs:
#         terraformVersion: $(tfVersion)

#     - task: AzureCLI@2
#       displayName: "Destroy All"
#       inputs:
#         azureSubscription: 'azure-rm-terraform'
#         scriptType: 'ps'
#         scriptLocation: 'inlineScript'
#         workingDirectory: $(workingDir)
#         inlineScript: |
#           $key = az storage account keys list --resource-group $(bkResourceGroup) --account-name $(bkStorageAccount) --query "[0].value" -o tsv
#           $env:ARM_ACCESS_KEY = $key

#           terraform init -input=false -reconfigure
#           terraform destroy -auto-approve -var "sql_password=$env:SQL_PASS"
#       env:
#         SQL_PASS: $(sql_password)