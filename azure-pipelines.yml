trigger:
- main

pool:
  name: local-pool

variables:
  # --- TERRAFORM VARS ---
  tfVersion: '1.9.0'
  workingDir: '$(System.DefaultWorkingDirectory)/terraform'
  bkResourceGroup: 'rg-terraform-backend'
  bkStorageAccount: 'tfstatedevopsapp123'
  bkContainer: 'tfstate'
  bkLocation: 'eastus'
  
  # --- CONNECTIONS ---
  acrLoginServer: 'devopsacr123.azurecr.io' 
  acrServiceConnection: 'acr-connection'    
  # We bypass aksServiceConnection in Deploy stage to avoid stale credential errors
  aksServiceConnection: 'aks-connection'            
  
  # --- IMAGES ---
  backendImageName: 'backend-app'
  frontendImageName: 'frontend-app'
  tag: '$(Build.BuildId)'
  
  # --- APP CONFIG (CRITICAL STEP) ---
  # 1. Get External IP of 'backend-service' from Azure Portal.
  # 2. Paste it below (e.g. 'http://20.55.12.11'). 
  # 3. DO NOT add :5000 (Your service.yml maps Port 80 -> 5000 automatically).
  backendUrl: 'http://<YOUR_BACKEND_IP_HERE>' 

  # --- SECURITY ---
  # Ensure 'snykToken' and 'sonarToken' are in your Pipeline Library/Variables
  # snykToken: '...'
  # sonarToken: '...'

stages:
# ----------------------------
# STAGE 1: INFRASTRUCTURE
# ----------------------------
- stage: Terraform
  displayName: "Infrastructure"
  jobs:
  - job: TerraformWorkflow
    displayName: "Terraform Workflow"
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(tfVersion)

    - task: AzureCLI@2
      displayName: "1. Bootstrap & Setup"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: |
          Write-Host "Checking Infrastructure Backend..."
          $rgExists = az group exists --name $(bkResourceGroup)
          if ($rgExists -eq "false") { az group create --name $(bkResourceGroup) --location $(bkLocation) }

          $accCheck = az storage account check-name --name $(bkStorageAccount) | ConvertFrom-Json
          if ($accCheck.nameAvailable -eq $true) {
             az storage account create --name $(bkStorageAccount) --resource-group $(bkResourceGroup) --location $(bkLocation) --sku Standard_LRS
             Start-Sleep -Seconds 10
          }

          $key = az storage account keys list --resource-group $(bkResourceGroup) --account-name $(bkStorageAccount) --query "[0].value" -o tsv
          $containerExists = az storage container exists --name $(bkContainer) --account-name $(bkStorageAccount) --account-key $key --query "exists" -o tsv
          if ($containerExists -ne "true") { az storage container create --name $(bkContainer) --account-name $(bkStorageAccount) --account-key $key }

          Write-Host "##vso[task.setvariable variable=ARM_ACCESS_KEY;issecret=true]$key"

    - task: AzureCLI@2
      displayName: "2. Terraform Init"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform init -input=false -reconfigure
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

    - task: AzureCLI@2
      displayName: "3. Terraform Plan"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform plan -out=tfplan -var "sql_password=$env:SQL_PASS"
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)
        SQL_PASS: $(sql_password)

    - task: AzureCLI@2
      displayName: "4. Terraform Apply"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform apply -auto-approve tfplan
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

# # ----------------------------
# # STAGE 2: SONARQUBE (DOCKER METHOD)
# # ----------------------------
# - stage: SonarQube
#   displayName: "SonarQube Analysis"
#   dependsOn: Terraform
#   condition: succeeded()
#   jobs:
#   - job: SonarScan
#     displayName: "Run SonarScanner via Docker"
#     steps:
#     - script: |
#         echo "Running SonarQube Scanner..."
#         # We use Docker to avoid 'Task Missing' errors on local agent
#         # host.docker.internal allows Docker to see your Localhost SonarQube
#         docker run --rm \
#           -v "$(System.DefaultWorkingDirectory):/usr/src" \
#           sonarsource/sonar-scanner-cli \
#           -Dsonar.projectKey="FullStackApp" \
#           -Dsonar.projectName="FullStackApp" \
#           -Dsonar.host.url="http://host.docker.internal:9000" \
#           -Dsonar.token="$(sonarToken)" \
#           -Dsonar.sources="frontend,backend" \
#           -Dsonar.exclusions="**/node_modules/**,**/build/**,**/dist/**"
#       displayName: "Execute Sonar Scanner"

# # ----------------------------
# # STAGE 3: SECURITY (Snyk/Trivy FS)
# # ----------------------------
# - stage: SecurityCode
#   displayName: "Security: Code Scan"
#   dependsOn: SonarQube
#   jobs:
#   - job: SnykScan
#     displayName: "Snyk (Dependencies)"
#     continueOnError: true 
#     steps:
#     - script: |
#         npm install -g snyk
#         snyk auth $(snykToken)
#         snyk test backend/ --continue-on-failure
#       displayName: "Run Snyk Scan"
#       condition: ne(variables['snykToken'], '')

#   - job: TrivyFS
#     displayName: "Trivy (Filesystem)"
#     continueOnError: true
#     steps:
#     - script: |
#         # SCANS CODE BEFORE BUILD
#         docker run --rm -v "$(System.DefaultWorkingDirectory):/app" aquasec/trivy fs /app --exit-code 0
#       displayName: "Run Trivy FS Scan"

# # ----------------------------
# # STAGE 4: BUILD, IMAGE SCAN & PUSH
# # ----------------------------
# - stage: BuildAndPush
#   displayName: "Build & Scan Images"
#   dependsOn: SecurityCode
#   condition: succeeded()
#   jobs:
#   - job: BuildImages
#     steps:
#     # --- BACKEND ---
#     - task: Docker@2
#       displayName: "Build Backend"
#       inputs:
#         command: build
#         repository: $(backendImageName)
#         dockerfile: 'backend/Dockerfile'
#         containerRegistry: $(acrServiceConnection)
#         tags: |
#           $(tag)
#           latest

#     # Trivy Image Scan (Backend)
#     - script: |
#         echo "Scanning Backend Image..."
#         docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image $(acrLoginServer)/$(backendImageName):$(tag) --exit-code 0
#       displayName: "Trivy Scan: Backend Image"
#       continueOnError: true

#     - task: Docker@2
#       displayName: "Push Backend"
#       inputs:
#         command: push
#         repository: $(backendImageName)
#         containerRegistry: $(acrServiceConnection)
#         tags: |
#           $(tag)
#           latest

#     # --- FRONTEND ---
#     - task: Docker@2
#       displayName: "Build Frontend"
#       inputs:
#         command: build
#         repository: $(frontendImageName)
#         dockerfile: 'frontend/Dockerfile'
#         containerRegistry: $(acrServiceConnection)
#         # INJECTS THE BACKEND URL INTO REACT APP
#         arguments: '--build-arg REACT_APP_API_URL=$(backendUrl)'
#         tags: |
#           $(tag)
#           latest

#     # Trivy Image Scan (Frontend)
#     - script: |
#         echo "Scanning Frontend Image..."
#         docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image $(acrLoginServer)/$(frontendImageName):$(tag) --exit-code 0
#       displayName: "Trivy Scan: Frontend Image"
#       continueOnError: true

#     - task: Docker@2
#       displayName: "Push Frontend"
#       inputs:
#         command: push
#         repository: $(frontendImageName)
#         containerRegistry: $(acrServiceConnection)
#         tags: |
#           $(tag)
#           latest

# # ----------------------------
# # STAGE 5: DEPLOY (AKS)
# # ----------------------------
# - stage: Deploy
#   displayName: "Deploy to AKS"
#   dependsOn: BuildAndPush
#   condition: succeeded()
#   jobs:
#   - deployment: DeployAKS
#     environment: 'production'
#     strategy:
#       runOnce:
#         deploy:
#           steps:
#             - task: AzureCLI@2
#               displayName: "Deploy with Dynamic Credentials"
#               inputs:
#                 azureSubscription: 'azure-rm-terraform'
#                 scriptType: 'ps'
#                 scriptLocation: 'inlineScript'
#                 inlineScript: |
#                   # 1. Clean up old credentials to fix "No Such Host" error
#                   if (Test-Path "$env:USERPROFILE\.kube\config") { Remove-Item "$env:USERPROFILE\.kube\config" -Force }

#                   # 2. Get Fresh Credentials
#                   az aks get-credentials --resource-group devops-rg --name devops-aks --overwrite-existing
                  
#                   # 3. Create DB Secret
#                   kubectl create secret generic db-secret --from-literal=password=$(sql_password) --dry-run=client -o yaml | kubectl apply -f -

#                   # 4. Update Manifests
#                   $manifests = "$(System.DefaultWorkingDirectory)/manifests/deployment.yml"
#                   (Get-Content $manifests) -replace 'backend-app:latest', "backend-app:$(tag)" -replace 'frontend-app:latest', "frontend-app:$(tag)" | Set-Content $manifests

#                   # 5. Apply Manifests
#                   kubectl apply -f "$(System.DefaultWorkingDirectory)/manifests/deployment.yml"
#                   kubectl apply -f "$(System.DefaultWorkingDirectory)/manifests/service.yml"

# # ----------------------------
# # STAGE 6: DESTROY (Manual)
# # ----------------------------
# - stage: DestroyInfra
#   displayName: "Destroy Infrastructure"
#   dependsOn: Deploy
#   condition: eq(variables['Build.Reason'], 'Manual') 
#   jobs:
#   - job: TerraformDestroy
#     displayName: "Terraform Destroy"
#     steps:
#     - task: TerraformInstaller@0
#       inputs:
#         terraformVersion: $(tfVersion)

#     - task: AzureCLI@2
#       displayName: "Destroy All"
#       inputs:
#         azureSubscription: 'azure-rm-terraform'
#         scriptType: 'ps'
#         scriptLocation: 'inlineScript'
#         inlineScript: |
#           $key = az storage account keys list --resource-group $(bkResourceGroup) --account-name $(bkStorageAccount) --query "[0].value" -o tsv
#           $env:ARM_ACCESS_KEY = $key
#           terraform init -input=false -reconfigure
#           terraform destroy -auto-approve -var "sql_password=$env:SQL_PASS"
#       env:
#         SQL_PASS: $(sql_password)