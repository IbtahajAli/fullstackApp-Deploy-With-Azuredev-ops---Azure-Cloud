trigger:
- main

pool:
  name: local-pool

variables:
  # --- TERRAFORM VARS ---
  tfVersion: '1.9.0'
  workingDir: '$(System.DefaultWorkingDirectory)/terraform'
  bkResourceGroup: 'rg-terraform-backend'
  bkStorageAccount: 'tfstatedevopsapp123'
  bkContainer: 'tfstate'
  bkLocation: 'eastus'
  
  # --- CONNECTIONS ---
  acrLoginServer: 'devopsacr123.azurecr.io' 
  acrServiceConnection: 'acr-connection'    
  # Bypass aksServiceConnection in Deploy to verify credentials dynamically
  aksServiceConnection: 'aks-connection'            
  sonarServiceConnection: 'sonarqube-local-connection'
  
  # --- IMAGES ---
  backendImageName: 'backend-app'
  frontendImageName: 'frontend-app'
  tag: '$(Build.BuildId)'
  
  # --- APP CONFIG ---
  # ⚠️ REPLACE THIS with the Real IP from Azure Portal (e.g. http://20.55.12.11)
  backendUrl: 'http://localhost:5000' 

  # --- SECURITY ---
  # Ensure 'snykToken' is in your Variables
  # snykToken: '...' 

stages:
# ----------------------------
# STAGE 1: INFRASTRUCTURE
# ----------------------------
- stage: Terraform
  displayName: "Infrastructure"
  jobs:
  - job: TerraformWorkflow
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(tfVersion)

    - task: AzureCLI@2
      displayName: "1. Bootstrap & Setup"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: |
          $rgExists = az group exists --name $(bkResourceGroup)
          if ($rgExists -eq "false") { az group create --name $(bkResourceGroup) --location $(bkLocation) }

          $accCheck = az storage account check-name --name $(bkStorageAccount) | ConvertFrom-Json
          if ($accCheck.nameAvailable -eq $true) {
             az storage account create --name $(bkStorageAccount) --resource-group $(bkResourceGroup) --location $(bkLocation) --sku Standard_LRS
             Start-Sleep -Seconds 10
          }

          $key = az storage account keys list --resource-group $(bkResourceGroup) --account-name $(bkStorageAccount) --query "[0].value" -o tsv
          $containerExists = az storage container exists --name $(bkContainer) --account-name $(bkStorageAccount) --account-key $key --query "exists" -o tsv
          if ($containerExists -ne "true") { az storage container create --name $(bkContainer) --account-name $(bkStorageAccount) --account-key $key }

          Write-Host "##vso[task.setvariable variable=ARM_ACCESS_KEY;issecret=true]$key"

    - task: AzureCLI@2
      displayName: "2. Terraform Init"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform init -input=false -reconfigure
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

    - task: AzureCLI@2
      displayName: "3. Terraform Plan"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform plan -out=tfplan -var "sql_password=$env:SQL_PASS"
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)
        SQL_PASS: $(sql_password)

    - task: AzureCLI@2
      displayName: "4. Terraform Apply"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        workingDirectory: $(workingDir)
        inlineScript: terraform apply -auto-approve tfplan
      env:
        ARM_ACCESS_KEY: $(ARM_ACCESS_KEY)

# ----------------------------
# STAGE 2: SONARQUBE (VIA DOCKER ON WINDOWS)
# ----------------------------

# ----------------------------
# STAGE 2: SONARQUBE
# ----------------------------
- stage: SonarQube
  displayName: "SonarQube Analysis"
  dependsOn: Terraform
  jobs:
  - job: SonarScan
    displayName: "Run SonarQube Analysis"
    pool:
      vmImage: 'windows-latest'   # or your agent pool
    steps:
    - task: SonarQubePrepare@8
      inputs:
        SonarQube: '$(sonarServiceConnection)'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: 'FullStackApp'
        cliProjectName: 'FullStackApp'
        extraProperties: |
          sonar.sources=frontend,backend
          sonar.exclusions=**/node_modules/**,**/build/**,**/dist/**
    - task: SonarQubeAnalyze@8
    - task: SonarQubePublish@8
      inputs:
        pollingTimeoutSec: '300'

# ----------------------------
# STAGE 3: SECURITY (Snyk/Trivy FS)
# ----------------------------
- stage: SecurityCode
  displayName: "Security: Code Scan"
  dependsOn: SonarQube # Runs after SonarQube
  jobs:
  - job: SnykScan
    displayName: "Snyk (Dependencies)"
    continueOnError: true 
    steps:
    - script: |
        npm install -g snyk
        snyk auth $(snykToken)
        snyk test backend/ --continue-on-failure
      displayName: "Run Snyk Scan"
      condition: ne(variables['snykToken'], '')

  - job: TrivyFS
    displayName: "Trivy (Filesystem)"
    continueOnError: true
    steps:
    - script: |
        # SCANS CODE BEFORE BUILD
        docker run --rm -v "$(System.DefaultWorkingDirectory):/app" aquasec/trivy fs /app --exit-code 0
      displayName: "Run Trivy FS Scan"

# ----------------------------
# STAGE 4: BUILD, IMAGE SCAN & PUSH
# ----------------------------
- stage: BuildAndPush
  displayName: "Build & Scan Images"
  dependsOn: SecurityCode
  condition: succeeded()
  jobs:
  - job: BuildImages
    steps:
    # --- BACKEND ---
    - task: Docker@2
      displayName: "Build Backend"
      inputs:
        command: build
        repository: $(backendImageName)
        dockerfile: 'backend/Dockerfile'
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(tag)
          latest

    # Trivy Image Scan (Backend)
    - script: |
        echo "Scanning Backend Image..."
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image $(acrLoginServer)/$(backendImageName):$(tag) --exit-code 0
      displayName: "Trivy Scan: Backend Image"
      continueOnError: true

    - task: Docker@2
      displayName: "Push Backend"
      inputs:
        command: push
        repository: $(backendImageName)
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(tag)
          latest

    # --- FRONTEND ---
    - task: Docker@2
      displayName: "Build Frontend"
      inputs:
        command: build
        repository: $(frontendImageName)
        dockerfile: 'frontend/Dockerfile'
        containerRegistry: $(acrServiceConnection)
        arguments: '--build-arg REACT_APP_API_URL=$(backendUrl)'
        tags: |
          $(tag)
          latest

    # Trivy Image Scan (Frontend)
    - script: |
        echo "Scanning Frontend Image..."
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image $(acrLoginServer)/$(frontendImageName):$(tag) --exit-code 0
      displayName: "Trivy Scan: Frontend Image"
      continueOnError: true

    - task: Docker@2
      displayName: "Push Frontend"
      inputs:
        command: push
        repository: $(frontendImageName)
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(tag)
          latest

# ----------------------------
# STAGE 5: DEPLOY (AKS)
# ----------------------------
- stage: Deploy
  displayName: "Deploy to AKS"
  dependsOn: BuildAndPush
  condition: succeeded()
  jobs:
  - deployment: DeployAKS
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureCLI@2
              displayName: "Deploy with Dynamic Credentials"
              inputs:
                azureSubscription: 'azure-rm-terraform'
                scriptType: 'ps'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  # 1. Clean up old credentials
                  if (Test-Path "$env:USERPROFILE\.kube\config") { Remove-Item "$env:USERPROFILE\.kube\config" -Force }

                  # 2. Get Fresh Credentials
                  az aks get-credentials --resource-group devops-rg --name devops-aks --overwrite-existing
                  
                  # 3. Create DB Secret
                  kubectl create secret generic db-secret --from-literal=password=$(sql_password) --dry-run=client -o yaml | kubectl apply -f -

                  # 4. Update Manifests
                  $manifests = "$(System.DefaultWorkingDirectory)/manifests/deployment.yml"
                  (Get-Content $manifests) -replace 'backend-app:latest', "backend-app:$(tag)" -replace 'frontend-app:latest', "frontend-app:$(tag)" | Set-Content $manifests

                  # 5. Apply Manifests
                  kubectl apply -f "$(System.DefaultWorkingDirectory)/manifests/deployment.yml"
                  kubectl apply -f "$(System.DefaultWorkingDirectory)/manifests/service.yml"

# ----------------------------
# STAGE 6: DESTROY (Manual)
# ----------------------------
- stage: DestroyInfra
  displayName: "Destroy Infrastructure"
  dependsOn: Deploy
  condition: eq(variables['Build.Reason'], 'Manual') 
  jobs:
  - job: TerraformDestroy
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: $(tfVersion)

    - task: AzureCLI@2
      displayName: "Destroy All"
      inputs:
        azureSubscription: 'azure-rm-terraform'
        scriptType: 'ps'
        scriptLocation: 'inlineScript'
        inlineScript: |
          $key = az storage account keys list --resource-group $(bkResourceGroup) --account-name $(bkStorageAccount) --query "[0].value" -o tsv
          $env:ARM_ACCESS_KEY = $key
          terraform init -input=false -reconfigure
          terraform destroy -auto-approve -var "sql_password=$env:SQL_PASS"
      env:
        SQL_PASS: $(sql_password)